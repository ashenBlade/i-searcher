# i-searcher

Консольный инструмент для информационного поиска по множеству документов с использованием алгоритма ранжирования BM25

# Сборка

Для сборки используется CMake. 
Исходники располагаются в `src`.
Также, используется библиотека Boost Program Options.
```shell
sudo apt update
sudo apt install libboost-program-options1.74-dev
```

Скрипт сборки (запускается из корня репозитория).
Для сборки создается 

```shell
mkdir cmake && cd cmake
cmake ../src
make
```

В директории `cmake` будет содержаться исполняемый файл `isearch`.

Дальше, для более удобной работы предлагаю обновить `$PATH`, для доступа к исполняемому файлу (чтобы каждый раз не указывать путь до бинарника).

```shell
# Предполагается, что запуск также из директории со сборкой - cmake
PATH="$PATH:$PWD"
```

# Работа 

Приложение работает в 2 режимах: инициализация и поиск

## Инициализация

Перед началом работы необходимо проинициализировать директорию с документами.
В качестве документов используются `.txt` файлы (расширение).
Содержимое - русский текст (другие языки корректно работать не будут).
Кодировка - UTF-8.

Команда: `isearch init [DIRECTORY] [-p|--parallel THREADS_COUNT]`
- `DIRECTORY` - путь до директории, которую нужно инициализировать. Если отсутствует, то инициализируется текущая директория
- `-p|--parallel THREADS_COUNT` - количество одновременных потоков, которое можно использовать. Если не указать или указать `0`, то будет использоваться количество равное количеству потоков процессора

Примеры:
- `isearch init .` - инициализировать текущую директорию
- `isearch init /home/user/Documents/Research` - инициализировать директорию `/home/user/Documents/Research` 

## Поиск

Поиск производится по уже существующей директории.

Команда: `isearch query QUERY DIRECTORY [-m|--max MAX] [-k|--bm25-k K_VALUE] [-b|--bm25-b B_VALUE] [-p|--parallel THREADS_COUNT]`
- `QUERY` - строка запроса по файлам. Необходимо указывать единой строкой - в кавычках. Например, `"река текла изгибаясь"` или `'футбольный матч'`
- `DIRECTORY` - директория, по которой необходимо производить поиск. В отличие от инициализации - обязательна
- `-m|--max MAX` - максимальное количество документов в результате - указывается в `MAX`
- `-k|--bm25-k K_VALUE` - значение k для алгоритма BM25 - указывается в `K_VALUE`
- `-b|--bm25-b B_VALUE` - значение b для алгоритма BM25 - указывается в `B_VALUE` 
- `-p|--parallel THREADS_COUNT` - количество одновременных потоков, которое можно использовать. По умолчанию, будет использоваться максимально возможное количество 

Примеры:
- `isearch query "пятничный праздник" . -m 200` - сделать запрос по документам в текущей директории по запросу "пятничный праздник" и выдать 200 документов
- `isearch query 'стройка в центре города' /var/lib/mongodb -k 9` - сделать запрос по документам в /var/lib/mongodb с параметром k равным 9

> Вывод документов производится в порядке релевантности

# Тестирование

Для тестирования используется датасет [Lenta.ru из Kaggle](https://www.kaggle.com/datasets/yutkin/corpus-of-russian-news-articles-from-lenta?select=lenta-ru-news.csv).
Он представляется в виде csv файла, но нам нужны только поля `title` - название документа и `text` - его содержимое.
Распарсить можно этим питоновским скриптом:

```python
import csv
import os


def main():
    try:
        os.mkdir('files')
    except FileExistsError:
        pass

    with open('lenta-ru-news.csv', 'r') as lenta_file:
        reader = csv.reader(lenta_file, delimiter=',')
        next(reader)  # Пропускаем заголовок
        for line in reader:
            title = line[1]
            text = line[2]
            try:
                with open(f'files/{title}.txt', 'w') as content_file:
                    content_file.write(text)
            except FileNotFoundError:
                # Не хочу экранировать символы - так проще
                pass


if __name__ == '__main__':
    main()
```

В результате в директории `files` будут все релевантные файлы. Дальше переходим в эту директорию и работаем в ней (либо перемещаем в нужное место):

```shell
cd files
```

После скачивания и распаковки необходимо запустить инициализацию:

```shell
isearch init .
```

> Предупреждение: датасет очень большой. У меня ушло 13Гб оперативки и 30-40 минут на весь процесс.

После инициализации можно запускать тесты

```shell
isearch query "футбольный матч" . -m 10
```

Результат поиска:

```text
Роналду сделал хет-трик в матче Лиги чемпионов.txt
Во втором туре Masters Cup Хьюитт обыграл Агасси.txt
Дик Адвокат вызвал в сборную России новичка из "Зенита".txt
Определились финалисты Кубка Либертадорес.txt
Фанаты сбили снимавший футбольный матч коптер туалетной бумагой.txt
"Зенит" назвал условие возвращения Денисова в основной состав.txt
Швеция защитила титул чемпиона мира по хоккею.txt
Русская певица дала болельщику клуба НХЛ урок крика.txt
В Варшаву приедут 350 фанатов "Глазго Рейнджерс".txt
Вместе с Колосковым в отставку уйдет руководство РФС.txt
```

## Детали реализации

### Инициализация

В результате инициализации, в директории с документами (указанную во время инициализации) создается директория для приложения - `.isearch`.
В ней находятся:
- `index` - файл с обратным индексом. По нему находятся возможные файлы, которые будут обрабатываться в дальнейшем
- `files` - директория с самими индексными файлами для каждого документа
- `files/xxxx` - индексный файл документа, где `xxx` - это id документа

После инициализации каждому документу назначается его id - целое число. 
Порядок назначения не фиксирован, но уникален в рамках всех документов.
Сейчас - это просто инкрементирующееся число.

В каждом индексном файле находится информация о содержимом документа, необходимое для ранжирования.

### Параллельное выполнение

Для производительности можно указывать количество потоков, которое нужно использовать в процессе работы.
Оно указывается ключом `-p` или `--parallel` (короткая и длинная версии).

При указании `0` будет использоваться количество равное количеству ядер/процессов - для наиболее эффективной работы.
Распараллеливание используется работы с файлами (чтение документов или индексных файлов, а также сохранение индексных файлов) и в процессе ранжирования.


### Стемминг

Для приведения слов к общему виду я использую алгоритм [Snowball](https://snowballstem.org/algorithms/russian/stemmer.html).
Реализация находится в [src/stemmer/RussianStemmer.cpp](./src/stemmer/RussianStemmer.cpp).

В дополнение, используется список стоп-слов. Пока он захардкожен, но может потом сделаю отдельным файлом.

### Алгоритм ранжирования

В качестве алгоритма ранжирования используется [Best Match 25 (BM25)](https://ru.wikipedia.org/wiki/Okapi_BM25).
При запуске приложения имеется возможность указания параметров: k и b.
Значения по умолчанию:
- k - `2`
- b - `0.75`

Реализация находится в [src/ranger/BM25Ranger.cpp](src/ranger/BM25Ranger.cpp).